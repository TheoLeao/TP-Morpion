<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TP - Morpion</title>
    <script src="js/script.js"></script>
    <style>
        .jeu {
            display: flex;
        }

        .jeu div {
            width: 100%;
        }
    </style>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"
        integrity="sha384-q2kxQ16AaE6UbzuKqyBE9/u/KzioAlnx2maXQHiDX9d4/zp8Ok3f+M7DPm+Ib6IU"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.min.js"
        integrity="sha384-pQQkAEnwaBkjpqZ8RU1fF1AKtTcHJwFl3pblpTlHXybJjHpMYo79HY3hIi4NKxyj"
        crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
</head>

<body>
    <div class="container">
        <div class="consigne">

            <h1>Consigne: TP : Réalisation d'un jeu de morpion 5x5. Pour gagner il faudra aligner quatre carrés
                ou quatre ronds.</h4>
                <div class="accordion" id="accordionExample">
                    <div class="accordion-item">
                        <h2 class="accordion-header" id="headingOne">
                            <button class="accordion-button" type="button" data-bs-toggle="collapse"
                                data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
                                Cliquez pour voir la consigne
                            </button>
                        </h2>
                        <div id="collapseOne" class="accordion-collapse collapse" aria-labelledby="headingOne"
                            data-bs-parent="#accordionExample">
                            <div class="accordion-body">
                                <ul>
                                    <li> <strike>1° Pour jouer, il faudra impérativement que les noms des deux joueurs
                                            soient
                                            saisis.</strike></li>
                                    <li>
                                        <strike>2° Les joueurs jouent alternativement. Le symbole <<<<< indique qui doit
                                                jouer. </strike>
                                    </li>
                                    <li>
                                        <strike>
                                            3° Si un joueur aligne 4 ronds ou 4 carrés, un message Gagné apparait à côté
                                            de
                                            son
                                            nom, son score augmente de 1, le jeu est bloqué et deux boutons apparaissent
                                            'Rejouer"
                                            et "Nouvelle
                                            partie".
                                        </strike>

                                    </li>

                                    <li>
                                        4° En cliquant sur Rejouer les deux même joueurs peuvent refaire une partie (le
                                        jeu
                                        précédent est effacé et les deux boutons sont masqués)
                                    </li>
                                    <li>
                                        5° En cliquant sur Nouvelle partie les noms et les scores sont effacés. Les deux
                                        boutons sont masqués.
                                    </li>
                                    <li>
                                        <strike>6° Chaque fois qu'un score évolue, les noms et les scores sont
                                            enregistrés en
                                            localStorage.</strike>
                                    </li>
                                    <li>
                                        7° Au démarrage d'une partie dans une nouvelle fenêtre du navigateur, si deux
                                        noms
                                        et deux scores sont enregistrés dans le localStorage, ils sont alors affichés
                                        avec les
                                        deux boutons 'Rejouer" et "Nouvelle partie".
                                    </li>
                                    <li>
                                        8° Lorsque 25 coups ont été joués sans réussir à aligner 4 ronds ou 4 carrés, le
                                        message "Partie nulle" s'affiche, la partie est bloquée et deux boutons
                                        'Rejouer" et
                                        "Nouvelle partie" sont rendus visibles.
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
        </div>
        <div class="jeu">
            <div>
                <canvas id="canvasJeu" width="500" height="500"></canvas>
            </div>
            <div class="infoJeu">
                <h2>Paramètre de la partie</h2>
                <div>


                    <label for="nomJoueur1" class="form-label mb-2 mt-2">Joueur n°1:</span></label>
                    <div id="alertWinJoueur1" class="" role="alert"></div>
                    <input class="form-control" id="nomJoueur1" type="text" placeholder="Nom joueur 1" required
                        value="Théo">
                    <label for="nomJoueur2" class="form-label mb-2 mt-2">Joueur n°2:</label>
                    <div id="alertWinJoueur2" class="" role="alert"></div>
                    <input class="form-control" id="nomJoueur2" type="text" placeholder="Nom joueur 2" required
                        value="Antoine">

                    <div class="card mt-4 mb-2">
                        <div class="card-body">
                            <p><u>Personnaliser la partie:</u></p>
                            <label for="inputRange_nombreDeCase" class="form-label">Nombre de case du morpion X et
                                Y:</label>
                            <label id="label_nombreCase"><b>5</b></label>
                            <input id="inputRange_nombreDeCase" type="range" class="form-range" min="3" max="9" step="1"
                                value="5">

                            <label for="inputRange_nombreDeCaseGagnante" class="form-label">Nombre de case à aligner
                                pour gagner:</label>
                            <label id="label_nombreCaseGagnante"><b>4</b></label>
                            <input id="inputRange_nombreDeCaseGagnante" type="range" class="form-range" min="3" max="8"
                                step="1" value="4">


                        </div>
                    </div>

                </div>


                <button id="btnRejouer" class="btn btn-secondary btn-sm" disabled>Rejouer</button>
                <button id="btnNouvellePartie" class="btn btn-success">Nouvelle partie</button>
                <div class="card mt-4 mb-2">
                    <div class="card-body">
                        <p><u>Score:</u></p>
                        <table class="table">
                            <thead>
                                <tr>
                                    <th scope="col"></th>
                                    <th scope="col">Joueur n°1</th>
                                    <th scope="col">Joueur n°2</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <th scope="row">Partie gagné</th>
                                    <td id="scoreJoueur1">0</td>
                                    <td id="scoreJoueur2">0</td>

                            </tbody>
                        </table>


                    </div>
                </div>
            </div>



        </div>
    </div>
</body>
<script>
    //Actualiser le label de inputRange nombre case au changement de sa valeur
    document.querySelector('#inputRange_nombreDeCase').addEventListener('input', function () {
        document.querySelector('#label_nombreCase').innerHTML = '';
        document.querySelector('#label_nombreCase').innerHTML = `<b>${this.value}</b>`;
    });

    //Actualiser le label de inputRange nombre de case gagnante au changement de sa valeur
    document.querySelector('#inputRange_nombreDeCaseGagnante').addEventListener('input', function () {
        document.querySelector('#label_nombreCaseGagnante').innerHTML = '';
        document.querySelector('#label_nombreCaseGagnante').innerHTML = `<b>${this.value}</b>`;
    });

    //Fonctions
    function createCanvas(idCanvas, width, height) {
        canvas = document.querySelector(`#${idCanvas}`);
        width = canvas.width = width;
        height = canvas.height = height;
        ctx = canvas.getContext('2d');
    }
    function drawX(originX, originY, size) {
        padding = 10;
        ctx.beginPath(); // Début du chemin
        ctx.moveTo(originX, originY); // Le tracé part du point 50,50
        ctx.lineTo(originX + size, originY + size); // Un segment est ajouté vers 200,200
        ctx.moveTo(originX + size, originY); // Puis on saute jusqu'à 200,50
        ctx.lineTo(originX, originY + size); // Puis on trace jusqu'à 50,200
        ctx.lineWidth = 7;
        ctx.strokeStyle = '#3FA7D6';
        ctx.lineCap = 'round';
        ctx.stroke();

    }
    function drawCircle(originX, originY, size) {
        ctx.beginPath();
        ctx.lineWidth = "7";
        ctx.strokeStyle = "#EE6352"
        ctx.arc(originX + size / 2, originY + size / 2, size / 2 - 5, 0, 2 * Math.PI);
        ctx.stroke();
    }
    function drawRect(originX, originY, width, height, fillColor) {
        ctx.beginPath();
        ctx.strokeStyle = "#FFFFFF";
        ctx.lineWidth = "1";
        ctx.rect(originX, originY, width, height);
        ctx.stroke();

    }
    function drawLimit(canvas, nombreLigne, nombreColonne, backgroundColor) {
        if (nombreLigne != nombreColonne) return (error('Le nombre de ligne n\'est pas égale au nombre de colonne'));;
        ctx.fillStyle = `${backgroundColor}`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        //Récuperer taille du canvas
        canvasWidth = canvas.width;
        canvasHeight = canvas.height;
        //Récuperer taille des cases
        caseWidth = canvasWidth / nombreColonne;
        caseHeight = canvasHeight / nombreLigne;

        //Tracer les lignes
        pair = true;
        //Chaque ligne
        for (i_line = 0; i_line <= nombreLigne; i_line++) {
            //Chaque case
            //console.log(`line ${i_line}`)
            for (i_case = 0; i_case < nombreColonne; i_case++) {
                if (pair) {
                    //console.log(`--case ${i_case}`);
                    drawRect(caseWidth * i_case, caseWidth * i_line, caseWidth, caseHeight, '#F9FAFC');
                    //drawX(caseWidth * i_case, caseHeight * i_line, caseWidth); //Test dessiné une croix 1 fois sur 2
                    pair = false;
                }
                else {
                    //console.log(`--case ${i_case}`);
                    drawRect(caseWidth * i_case, caseWidth * i_line, caseWidth, caseHeight, '#F4F9FF');
                    //drawCircle(caseWidth * i_case, caseHeight * i_line, caseWidth); //Test dessiné un cercle 1 fois sur 2
                    pair = true;
                }

            }
        }

    }
    function createMatrice(nombreLigne, nombreColonne) {
        matrice = Array.from(
            { length: nombreColonne }, () => Array.from(
                { length: nombreLigne }, () => ('')
            )
        )
    }
    function casePlayed(caseMatrice) {
        if (!caseMatrice == '') return true;
        return false;
    }
    function coupGagnantHorizontal(nombreGagnant, coup, symbole) {
        colonne = coup[0];
        ligne = coup[1];
        aVerifDroite = aVerifGauche = 0;
        countColonne1 = countColonne2 = colonne;
        valideADroite = valideAGauche = 0;

        //Récupérer le nombre de case à vérifier à droite
        while (countColonne1 < matrice[0].length - 1) {
            countColonne1++;
            aVerifDroite++;
            //console.log('+1')
        }
        //Récupérer le nombre de case à vérifier à gauche
        while (countColonne2 > 0) {
            countColonne2--;
            aVerifGauche++;
        }
        //console.log(`à verif Gauche: ${aVerifGauche} | à verif Droite: ${aVerifDroite}`);
        //Vérifier les cases à vérifier à droite 
        for (i = 1; i <= aVerifDroite; i++) {
            console.log(`vérification case ${colonne + i}:`)
            //Si la case suivante n'est pas valide
            if (matrice[ligne][colonne + i] !== symbole) {
                //console.log('pasegalX');
                //Arrêter de parcourir
                break;
            }
            //Sinon, ajouter 1 à valideADroite
            else {
                //console.log('egalX');
                valideADroite++;
            }
        }
        //Vérifier les cases à vérifier à gauche 
        for (i = 1; i <= aVerifGauche; i++) {
            console.log(`vérification case ${colonne + i}:`)
            //Si la case suivante n'est pas valide
            if (matrice[ligne][colonne - i] !== symbole) {
                //console.log('pasegalX');
                //Arrêter de parcourir
                break;
            }
            //Sinon, ajouter 1 à valideADroite
            else {
                //console.log('egalX');
                valideAGauche++;
            }
        }

        if (valideAGauche + valideADroite == nombreGagnant - 1) {
            return true;
        }
        //console.log(`colonne: ${colonne} limit:${matrice[0].length - 1} | caseAVerifGauche: ${aVerifGauche} | case valide Gauche: ${valideAGauche} caseAVerifDroite = ${aVerifDroite} | valideADroite: ${valideADroite}`)
    }
    function coupGagnantVertical(nombreGagnant, coup, symbole) {
        colonne = coup[0];
        ligne = coup[1];

        aVerifBas = aVerifHaut = 0;
        countLigne1 = countLigne2 = ligne;
        valideEnHaut = valideEnBas = 0;

        //Récuperer le nombre de case à vérifier en bas de la position joué
        while (countLigne2 < matrice.length - 1) {
            countLigne2++;
            aVerifBas++;
        }
        //Récuperer le nombre de case à vérifier en haut de la position joué
        while (countLigne1 > 0) {
            countLigne1--;
            aVerifHaut++;
        }

        //Vérifier les coups gagnents en bas de la position joué
        for (i = 1; i <= aVerifBas; i++) {
            if (matrice[ligne + i][colonne] !== symbole) {
                //console.log('pasegalX');
                //Arrêter de parcourir
                break;
            }
            //Sinon, ajouter 1 à valideADroite
            else {
                //console.log('egalX');
                valideEnBas++;
            }
        }

        //Vérifier les cases à vérifier en haut de la position joué 
        for (i = 1; i <= aVerifHaut; i++) {
            console.log(`vérification case ${colonne + i}:`)
            //Si la case suivante n'est pas valide
            if (matrice[ligne - i][colonne] !== symbole) {
                //console.log('pasegalX');
                //Arrêter de parcourir
                break;
            }
            //Sinon, ajouter 1 à valideADroite
            else {
                //console.log('egalX');
                valideEnHaut++;
            }
        }


        if (valideEnBas + valideEnHaut == nombreGagnant - 1) {
            return true;
        }

        //console.log(`ligne: ${ligne} limit:${matrice.length - 1} | caseAVerifHaut ${aVerifHaut} | case valide haut: ${valideEnHaut} caseAVerifBas = ${aVerifBas} | case valide bas: ${valideEnBas}`)
    }
    function coupGagnantDiagonaleGauche(nombreGagnant, coup, symbole) {
        colonne = coup[0];
        ligne = coup[1];

        aVerifBas = aVerifGauche = aVerifDroite = aVerifHaut = aVerifBasDroit = aVerifHautGauche = 0;

        countLigne1 = countLigne2 = ligne;
        countColonne1 = countColonne2 = colonne;
        valideEnHautGauche = valideEnBasDroit = 0;

        //Récuperer le nombre de case à vérifier en haut de la position joué
        while (countLigne1 > 0) {
            countLigne1--;
            aVerifHaut++;
        }

        //Récupérer le nombre de case à vérifier à gauche
        while (countColonne2 > 0) {
            countColonne2--;
            aVerifGauche++;
        }

        //Récuperer le nombre de case à vérifier en bas de la position joué
        while (countLigne2 < matrice.length - 1) {
            countLigne2++;
            aVerifBas++;
        }
        //Récupérer le nombre de case à vérifier à droite
        while (countColonne1 < matrice[0].length - 1) {
            countColonne1++;
            aVerifDroite++;
            //console.log('+1')
        }

        //Récuperer combien de diagonale à gauche vérifier (hautGauche):
        while (aVerifHaut > 0 && aVerifGauche > 0) {
            aVerifHaut--;
            aVerifGauche--;
            aVerifHautGauche++;
        }

        //Récuperer combien de diagonale à droite vérifier (basDroite):
        while (aVerifBas > 0 && aVerifDroite > 0) {
            aVerifBas--;
            aVerifDroite--;
            aVerifBasDroit++;
        }

        //Vérifier les coups gagnants diagonale en HautAGauche de la position joué
        for (i = 1; i <= aVerifHautGauche; i++) {
            if (matrice[ligne - i][colonne - i] !== symbole) {
                //console.log('pasegalX');
                //Arrêter de parcourir
                break;
            }
            //Sinon, ajouter 1 à valideADroite
            else {
                //console.log('egalX');
                valideEnHautGauche++;
            }
        }

        //Vérifier les coups gagnants diagonale en BasGauche de la position joué
        for (i = 1; i <= aVerifBasDroit; i++) {
            if (matrice[ligne + i][colonne + i] !== symbole) {
                //console.log('pasegalX');
                //Arrêter de parcourir
                break;
            }
            //Sinon, ajouter 1 à valideADroite
            else {
                //console.log('egalX');
                valideEnBasDroit++;
            }
        }
        if (valideEnHautGauche + valideEnBasDroit == nombreGagnant - 1) {
            return true;
        }
        //console.log(`ligne: ${ligne} colonne: ${colonne} | caseAVerifHautGauche ${aVerifHautGauche} | caseValidHautGauche: ${valideEnHautGauche} caseAVerifBasDroit: ${aVerifBasDroit} caseValideBasDroit: ${valideEnBasDroit}`)
    }
    function coupGagnantDiagonaleDroite(nombreGagnant, coup, symbole) {
        colonne = coup[0];
        ligne = coup[1];

        aVerifBas = aVerifGauche = aVerifDroite = aVerifHaut = aVerifHautDroite = aVerifBasGauche = 0;

        countLigne1 = countLigne2 = ligne;
        countColonne1 = countColonne2 = colonne;
        valideHautDroite = valideBasGauche = 0;

        //Récuperer le nombre de case à vérifier en haut de la position joué
        while (countLigne1 > 0) {
            countLigne1--;
            aVerifHaut++;
        }
        //Récuperer le nombre de case à vérifier à droite de la position joué
        while (countColonne1 < matrice[0].length - 1) {
            countColonne1++;
            aVerifDroite++;
        }

        //Récuperer combien de diagonale haut droite à  vérifier (hautDroite):
        while (aVerifHaut > 0 && aVerifDroite > 0) {
            aVerifHaut--;
            aVerifDroite--;
            aVerifHautDroite++;
        }

        //Récuperer le nombre de case à vérifier en bas de la position joué
        while (countLigne2 < matrice.length - 1) {
            countLigne2++;
            aVerifBas++;
        }

        //Récupérer le nombre de case à vérifier à gauche
        while (countColonne2 > 0) {
            countColonne2--;
            aVerifGauche++;
        }

        //Récuperer combien de diagonale haut gauche à  vérifier (hautDroite):
        while (aVerifBas > 0 && aVerifGauche > 0) {
            aVerifBas--;
            aVerifGauche--;
            aVerifBasGauche++;
        }

        //Vérifier les coups gagnants diagonale en BasGauche de la position joué
        for (i = 1; i <= aVerifBasGauche; i++) {
            if (matrice[ligne + i][colonne - i] !== symbole) {
                //console.log('pasegalX');
                //Arrêter de parcourir
                break;
            }
            //Sinon, ajouter 1 à valideADroite
            else {
                //console.log('egalX');
                valideBasGauche++;
            }
        }

        //Vérifier les coups gagnants diagonale en HautDroite de la position joué
        for (i = 1; i <= aVerifHautDroite; i++) {
            if (matrice[ligne - i][colonne + i] !== symbole) {
                //Arrêter de parcourir
                break;
            }
            //Sinon, ajouter 1 à valideADroite
            else {
                valideHautDroite++;
            }
        }

        if (valideHautDroite + valideBasGauche == nombreGagnant - 1) {
            return true;
        }

        //console.log(`ligne: ${ligne} colonne: ${colonne} | caseAVerifHautDroit: ${aVerifHautDroite} | valideHautDroite: ${valideHautDroite} caseAVerifBasGauche: ${aVerifBasGauche} | valideBasGauche: ${valideBasGauche}`)
    }
    function coupGagnant(nombreGagnant, coup, symbole) {
        if (coupGagnantHorizontal(nombreGagnant, coup, symbole)) return true;
        if (coupGagnantVertical(nombreGagnant, coup, symbole)) return true;
        if (coupGagnantDiagonaleGauche(nombreGagnant, coup, symbole)) return true;
        if (coupGagnantDiagonaleDroite(nombreGagnant, coup, symbole)) return true;
        return false;
    }
    function actualiserLabelJoueur(idJoueur, nomJoueur1, nomJoueur2) {
        if (idJoueur == 1) {
            document.querySelector('label[for="nomJoueur1"]').innerHTML = `Joueur n°1: <b>${nomJoueur1}</b> <<<<`;
            document.querySelector('label[for="nomJoueur2"]').innerHTML = `Joueur n°2: <b>${nomJoueur2}</b> `;
            console.log(document.querySelector('label[for="nomJoueur1"]'));
            console.log('actualisé');
        }
        if (idJoueur == 2) {
            document.querySelector('label[for="nomJoueur1"]').innerHTML = `Joueur n°1: <b>${nomJoueur1}</b> `;
            document.querySelector('label[for="nomJoueur2"]').innerHTML = `Joueur n°2: <b>${nomJoueur2}</b> <<<<`;
            console.log(document.querySelector('label[for="nomJoueur2"]').innerHTML);
        }
    }
    function saveLocalStorage(nameVariable, newValue) {
        localStorage.setItem(nameVariable, JSON.stringify(newValue));
        //Actualiser le tableau score
    }
    function gameListener(sizeCanvas, nombreCase, nombreSymboleGagnant, nomJoueur1, nomJoueur2) {
        canvas.addEventListener('click', function (e) {
            //Récupération des coordonnées de la sourie
            sizeCase = sizeCanvas / nombreCase;
            let x = Math.ceil(e.offsetX / sizeCase) * sizeCase - sizeCase;
            let y = Math.ceil(e.offsetY / sizeCase) * sizeCase - sizeCase;
            // console.log(`${x / 100} et ${y / 100}`);

            //Vérifier si la case a été joué | 
            ligne = Math.round(y / sizeCase);
            colonne = Math.round(x / sizeCase);
            if (!casePlayed(matrice[ligne][colonne])) {
                //Jouer le tour
                if (tour == 1) {
                    matrice[ligne][colonne] = 'X'; //Inverser pour pouvoir visualiser dans la matrice
                    console.log(matrice);
                    drawX(x, y, caseWidth, caseHeight)

                    if (coupGagnant(nombreSymboleGagnant, [colonne, ligne], 'X')) {
                        tour = 0;
                        //Ajouter un point au joueur 1
                        game.addPoint(1);
                        //Sauvegarder la game
                        saveLocalStorage('game', game);
                        actualiserScores(game.joueur1.score, game.joueur2.score);
                        //Afficher et masquer l'alert pour dire que le joueur a gagné
                        document.getElementById('alertWinJoueur1').classList = 'alert show alert-success';
                        document.getElementById('alertWinJoueur1').innerHTML = `Ce joueur remporte la partie`;
                        window.setTimeout(function () {
                            document.getElementById('alertWinJoueur1').removeAttribute('style');
                            document.getElementById('alertWinJoueur1').classList = 'alert fade alert-success';
                            $(".alert").fadeTo(500, 0).slideUp(500, function () {
                            });
                            //Supprimer le texte 1 seconde après
                            setTimeout(function () {
                                document.getElementById('alertWinJoueur1').innerHTML = '';
                                setTimeout(function () {
                                    document.getElementById('alertWinJoueur1').removeAttribute('style');
                                    document.getElementById('alertWinJoueur1').classList = '';
                                }, 1000)
                            }, 1000)

                        }, 2000);
                        //Permettre de cliquer sur le bouton rejouer
                        document.querySelector('#btnRejouer').removeAttribute('disabled');

                    }
                    else {
                        tour = 2;
                        actualiserLabelJoueur(2, nomJoueur1, nomJoueur2);
                    }

                    //ifCoupGagnant tour = 0 sinon tour = 2

                }
                else if (tour == 2) {
                    matrice[ligne][colonne] = 'O'; //Inverser pour pouvoir visualiser dans la matrice
                    drawCircle(x, y, caseWidth);
                    if (coupGagnant(nombreSymboleGagnant, [colonne, ligne], 'O')) {
                        tour = 0;

                        //Ajouter un point au joueur 1
                        game.addPoint(2);
                        //Sauvegarder la game
                        saveLocalStorage('game', game);
                        actualiserScores(game.joueur1.score, game.joueur2.score);
                        //Afficher et masquer l'alert pour dire que le joueur a gagné
                        document.getElementById('alertWinJoueur2').classList = 'alert show alert-success';
                        document.getElementById('alertWinJoueur2').innerHTML = `Ce joueur remporte la partie`;
                        window.setTimeout(function () {
                            $(".alert").fadeTo(500, 0).slideUp(500, function () {
                            });
                            //Supprimer le texte 1 seconde après
                            setTimeout(function () {
                                document.getElementById('alertWinJoueur2').innerHTML = '';
                                //Renitialiser l'état de l'alert
                                setTimeout(function () {
                                    document.getElementById('alertWinJoueur2').removeAttribute('style');
                                    document.getElementById('alertWinJoueur2').classList = '';
                                }, 1000)
                            }, 1000)

                        }, 2000);
                        //Permettre de cliquer sur le bouton rejouer
                        document.querySelector('#btnRejouer').removeAttribute('disabled')

                    }
                    else {
                        tour = 1;
                        actualiserLabelJoueur(1, nomJoueur1, nomJoueur2);

                    }
                }
            }
            //console.log(matrice);
        });
    }
    function createObjectGame(nomJoueur1, nomJoueur2) {
        partie = {
            joueurs: [{
                nom: 'Théo',
                signe: 'X',
                score: 2,
            },
            {
                nom: 'Théo',
                signe: 'O',
                score: 2
            }],
            matrice: [],
        }
    }

    class Game {
        constructor(joueur1, joueur2, matrice) {
            this.joueur1 = joueur1;
            this.joueur2 = joueur2;
            this.matrice = matrice;
        }
        addPoint(joueur) {
            if (joueur == 1) this.joueur1.score++;
            if (joueur == 2) this.joueur2.score++;
        }
    }

    function createGameObject(joueur1, joueur2, matrice) {
        game = new Game(joueur1, joueur2, matrice);
    }

    function actualiserScores(scoreJoueur1, scoreJoueur2) {
        document.querySelector('#scoreJoueur1').innerHTML = `${scoreJoueur1}`;
        document.querySelector('#scoreJoueur2').innerHTML = `${scoreJoueur2}`;
    }

    function nouvellePartie(idCanvas, sizeCanvas, backgroundColorCanvas) {

        //Joueurs
        let nomJoueur1 = document.querySelector('#nomJoueur1').value;
        let nomJoueur2 = document.querySelector('#nomJoueur2').value;
        var nombreCase = document.querySelector('#inputRange_nombreDeCase').value;
        var nombreSymboleGagnant = document.querySelector('#inputRange_nombreDeCaseGagnante').value;
        alert(`symbole gagnant: ${nombreSymboleGagnant} | nombreCase: ${nombreCase}`);
        //Vérifier le joueur 1
        if (nomJoueur1 !== undefined && nomJoueur1 !== '' && nomJoueur1.length >= 2) {
            //Vérifier le joueur 2
            if (nomJoueur2 !== undefined && nomJoueur2 !== '' && nomJoueur2.length >= 1) {
                if (nombreSymboleGagnant < nombreCase) {
                    createCanvas(idCanvas, sizeCanvas, sizeCanvas);

                    drawLimit(canvas, nombreCase, nombreCase, backgroundColorCanvas);
                    tour = 1;







                    gameListener(sizeCanvas, nombreCase, nombreSymboleGagnant, nomJoueur1, nomJoueur2);


                    //Afficher les noms des joueurs dans l'input
                    document.querySelector('label[for="nomJoueur1"]').innerHTML += ` <b>${nomJoueur1}</b>`;
                    document.querySelector('label[for="nomJoueur2"]').innerHTML += ` <b>${nomJoueur2}</b>`;

                    actualiserLabelJoueur(1, nomJoueur1, nomJoueur2);

                    createMatrice(nombreCase, nombreCase);
                    createGameObject({ 'nom': nomJoueur1, 'score': 0 }, { 'nom': nomJoueur2, 'score': 0 }, matrice);
                    saveLocalStorage('game', game);
                    actualiserScores(game.joueur1.score, game.joueur2.score);
                    //Ajouter les noms au label

                    localStorage.setItem('game', JSON.stringify(game));


                }
                else {
                    alert(`Nombre symbole gagnant superieur à nombre de case ${nombreSymboleGagnant} > ${nombreCase}`);
                }


            }
            else {
                alert('joueur 2 pas ok')
                console.log(nomJoueur1)
            }

        }
        else {
            alert('joueur 1 pas ok')
            console.log(nomJoueur1)
        }



    }
    //Si une game est présente en storage: récuperer nom et afficher
    if (localStorage.getItem('game') !== null && localStorage.getItem('game') !== '') {
        exGame = JSON.parse(localStorage.getItem('game'));
        game = new Game({ 'nom': exGame.joueur1.nom, 'score': exGame.joueur1.score }, { 'nom': exGame.joueur2.nom, 'score': exGame.joueur2.score });

        //Afficher les noms des joueurs dans l'input
        document.querySelector('label[for="nomJoueur1"]').innerHTML += ` <b>${game.joueur1.nom}</b>`;
        document.querySelector('label[for="nomJoueur2"]').innerHTML += ` <b>${game.joueur2.nom}</b>`;

        //Afficher les scores
        actualiserScores(game.joueur1.score, game.joueur2.score);

        //Permettre de cliquer sur rejouer
        document.querySelector('#btnRejouer').removeAttribute('disabled');



    }

    document.querySelector('#btnNouvellePartie').addEventListener('click', function () {
        nouvellePartie('canvasJeu', 400, 'rgb(248,241,241)');
    })
    document.querySelector('#btnRejouer').addEventListener('click', function () {
        //Re-bloquer l'accès au bouton rejouer
        //document.querySelector('#btnRejouer').setAttribute('disabled', 'disabled');

        //Récupérer les variables: nombreCase, nombreCase
        var nombreCase = document.querySelector('#inputRange_nombreDeCase').value;
        var nombreSymboleGagnant = document.querySelector('#inputRange_nombreDeCaseGagnante').value;




        //Si on revient sur la page, reintialiser quelques paramètres
        if (typeof canvas == 'undefined'){
            createCanvas('canvasJeu', 400, 400)
            gameListener(400, nombreCase, nombreSymboleGagnant, game.joueur1.nom, game.joueur1.nom)
        };
        drawLimit(canvas, nombreCase, nombreCase, 'rgb(248,241,241)');
        //Creer la nouvelle matrice
        createMatrice(nombreCase, nombreCase);
        if (typeof tour == 'undefined') tour = 1;

        //Redessiner par-dessus


        //Faire commencer l'autre joueur



        if (tour == 0) tour = 1;

        alert(tour);

    });

    /* window.setTimeout(function() {
    $(".alert").fadeTo(500, 0).slideUp(500, function(){
        $(this).remove();
    });
    }, 2000);*/


</script>

</html>